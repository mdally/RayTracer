#ifndef _MY_SCENE_H_
#define _MY_SCENE_H_

#include "cse452.h"
#include "Color.h"
#include "camera/Camera.h"
#include "parser.h"
#include "Light.h"
#include <FL/Fl_Image.H>
#include <string>
#include <vector>
#include <map>
#include "../shapes/Shape.h"

/*
 * This class holds all of the data in the scene file.
 *  Camera
 *  Lights
 *  Subgraphs
 *  Root subgraph
 */

// TODO: Define these

enum shapeType {CUBE, CYLINDER, CONE, SPHERE};

class Object {
public:
	Object();

	/*
	ambient		The ambient color							<color>				ambient 0 0 0
	diffuse		The diffuse color							<color>				diffuse 1 1 1
	reflect		The reflected color							<color>				reflect 0 0 0
	specular	The specular color							<color>				specular 0 0 0
	shine		The specular exponent						<index>				shine 1
	transparent The transparency							<color>				transparent 0 0 0
	ior			The index of refraction						<index>				ior 1
	texture		The texture map								<filename> <u> <v>	texture wood.ras 2 4
	emit		The emission color (for path tracing only)	<color>				emit 0 0 0
	*/
	shapeType type;
	Color ambient;
	Color diffuse;
	Color reflect;
	Color specular;
	Color transparent;
	Color emit;
	double shine;
	double ior;

	bool textureSet;
	std::string textureFileName;
	double textureU;
	double textureV;
private:
};

class Tree;
class Node {
public:
	Node();

	Matrix4 transformations;
	Object* object;
	Tree* subgraph;
private:
};

class Tree {
public:
	~Tree();

	void drawSubgraph();

	std::vector<Node*> rootNodes;
private:
};

class MyScene {
public:
    MyScene();
    ~MyScene();

    // The start of the parsing routine
    // Called once when a new scene file is opened
    bool loadSceneFile(std::string filename);

    // Return the current error mesage (if any) generated by parsing
    std::string getErrorMessage() const;

    // Return the parsed camera
    Camera &changeCamera();

    // Return the parsed camera
    const Camera &getCamera() const;

    // Return the parsed camera
    const Color &getBackground() const;

    // Called when the window is re-sized
    void resize(int w, int h);
    // Called when the window needs to be re-drawn
    // Stub can be found in sceneview/MyScene_draw.cpp
    void draw();
    
    /* 
     * The following are for the user interaction assignment 
     * Stubs for them can be found in Interactive/MySceneSelect.cpp
     */
    // User clicked on the screen; find the corresponding shape
    bool selectNode(int x, int y);
    //
    void moveSelectedNode( const Matrix4 &matChange );
    
    /*
     * The following are for the ray tracing assignment
     * Stubs for them can be found in rendering/MyScene_render.cpp
     */
    // 
    void render(int type, int width, int height, unsigned char* pixels);
    void stopRender();
    double getRenderProgress();

    /*
     * The following are for the sceneview assignment
     * They can be found in sceneview/MyScene.cpp
     */
    // Clear out any existing data
    void resetScene();

    // Gets the background color from the scenefile
    bool parseBackground(Parser& p);

    // Gets the camera info (if any) from the scene file
    bool parseCamera(Parser& p);

    // Gets the light info (if any) from the scene file
    bool parseLight(Parser& p);

    /*
     * The following are the parsing routines you need to finish filling in.
     * Feel free to change the return type or pass in additional parameters.
     */
    // Called when subgraph _name_ [ is encountered in the scene file
    // Should return true when root subgraph encountered
    Tree* parseMasterSubgraph(Parser& p);

    // Called when trans [ is encountered
    Node* parseTrans(Parser& p);

    // Called when Object _name_ [ is encountered
    Object* parseObject(Parser& p);

private:
    // Has loadSceneFile been called yet?
    bool isLoaded;
    // Keep track of the current error message
    std::string errorMessage;
    
    // Store camera info; remember that your default camera should be
    // set to reasonable values in case there is no camera information
    // in the scene file
    Camera camera;

    // Stores the background color found in the scenefile (if any).
    // Defaults to black
    Color background;

    // The stored lights
    Color ambientLight;
    std::vector<Light> lights;

    // your functions/variables go here
	//sceneview
		void deleteSubgraphs();
		void drawSubgraph(Tree* t);

		Tree* root;
		std::map<std::string, Tree*> subgraphs;

		Cube* cube;
		Cylinder* cylinder;
		Cone* cone;
		Sphere* sphere;

	//rendering
		unsigned char* pixelArray;
		int screenWidth;
		int screenHeight;
		bool keepWorking;
		double renderProgress;
		std::vector<Matrix4> transformStack;
		Object* obj;

		void rayTrace(Point3, Vector3);
		void castRayAgainstSubgraph(Point3, Vector3, Tree*, HitRecord*);
		void castLight(const Point3& src, const Point3& dst, Light& l, int depth, double distance, Color* reflectedColor);
		void getScreenCoord(const Point3& p, int& col, int& row);
		inline int pxIdx(int col, int row);
};

#endif /* _MY_SCENE_H_ */
